using LearnApp.Models;
using LearnApp.PageModels.Base;
using LearnApp.Services;
using System;
using System.Collections.Generic;
using System.Text;
using System.Threading.Tasks;
using Xamarin.CommunityToolkit.ObjectModel;

namespace LearnApp.PageModels.Data
{
    public static class LecturesData
    {
        public static async Task<ObservableRangeCollection<Lecture>> GetDataAsync()
        {
            var Lecture = new ObservableRangeCollection<Lecture>();
            var item = await PageModelLocator.Resolve<IRepositoryLectures<DataLectures>>().Get("Id");
            Lecture.Add(new Lecture
            {
                Chapter = "Глава 1",
                Title = "Язык C# и платформа .NET",
                Discription1 = @"       На сегодняшний момент язык программирования C# один из самых мощных, быстро развивающихся и востребованных языков в ИТ-отрасли. В настоящий момент на нем пишутся самые различные приложения: от небольших десктопных программок до крупных веб-порталов и веб-сервисов, обслуживающих ежедневно миллионы пользователей.
    C# уже не молодой язык и как и вся платформа .NET уже прошел большой путь. Первая версия языка вышла вместе с релизом Microsoft Visual Studio .NET в феврале 2002 года. Текущей версией языка является версия C# 10.0, которая вышла 8 ноября 2021 года вместе с релизом .NET 6.
    C# является языком с Си-подобным синтаксисом и близок в этом отношении к C++ и Java. Поэтому, если вы знакомы с одним из этих языков, то овладеть C# будет легче.
    C# является объектно-ориентированным и в этом плане много перенял у Java и С++. Например, C# поддерживает полиморфизм, наследование, перегрузку операторов, статическую типизацию. Объектно-ориентированный подход позволяет решить задачи по построению крупных, но в тоже время гибких, масштабируемых и расширяемых приложений. И C# продолжает активно развиваться, и с каждой новой версией появляется все больше интересных функциональностей.",
                Image1 = "carbon1.png",
                Discription2 = @"   Когда говорят C#, нередко имеют в виду технологии платформы .NET (Windows Forms, WPF, ASP.NET, Xamarin). И, наоборот, когда говорят .NET, нередко имеют в виду C#. Однако, хотя эти понятия связаны, отождествлять их неверно. Язык C# был создан специально для работы с фреймворком .NET, однако само понятие .NET несколько шире.
    Как-то Билл Гейтс сказал, что платформа .NET - это лучшее, что создала компания Microsoft. Возможно, он был прав. Фреймворк .NET представляет мощную платформу для создания приложений. Можно выделить следующие ее основные черты:
- Поддержка нескольких языков. Основой платформы является общеязыковая среда исполнения Common Language Runtime (CLR), благодаря чему .NET поддерживает несколько языков: наряду с C# это также VB.NET, C++, F#, а также различные диалекты других языков, привязанные к .NET, например, Delphi.NET. При компиляции код на любом из этих языков компилируется в сборку на общем языке CIL (Common Intermediate Language) - своего рода ассемблер платформы .NET. Поэтому при определенных условиях мы можем сделать отдельные модули одного приложения на отдельных языках.
- Кроссплатформенность. .NET является переносимой платформой (с некоторыми ограничениями). Например, последняя версия платформы на данный момент - .NET 6 поддерживается на большинстве современных ОС Windows, MacOS, Linux. Используя различные технологии на платформе .NET, можно разрабатывать приложения на языке C# для самых разных платформ - Windows, MacOS, Linux, Android, iOS, Tizen.
- Мощная библиотека классов. .NET представляет единую для всех поддерживаемых языков библиотеку классов. И какое бы приложение мы не собирались писать на C# - текстовый редактор, чат или сложный веб-сайт - так или иначе мы задействуем библиотеку классов .NET.
- Разнообразие технологий. Общеязыковая среда исполнения CLR и базовая библиотека классов являются основой для целого стека технологий, которые разработчики могут задействовать при построении тех или иных приложений. Например, для работы с базами данных в этом стеке технологий предназначена технология ADO.NET и Entity Framework Core. Для построения графических приложений с богатым насыщенным интерфейсом - технология WPF и WinUI, для создания более простых графических приложений - Windows Forms. Для разработки кроссплатформенных мобильных и десктопных приложений - Xamarin/MAUI. Для создания веб-сайтов и веб-приложений - ASP.NET и т.д.
    К этому стоит добавить активной развивающийся и набирающий популяность Blazor - фреймворк, который работает поверх .NET и который позволяет создавать веб-приложения как на стороне сервера, так и на стороне клиента. А в будущем будет поддерживать создание мобильных приложений и, возможно, десктоп-приложений.
    Производительность. Согласно ряду тестов веб-приложения на .NET 6 в ряде категорий сильно опережают веб-приложения, построенные с помощью других технологий. Приложения на .NET 6 в принципе отличаются высокой производительностью.
    Также еще следует отметить такую особенность языка C# и фреймворка .NET, как автоматическая сборка мусора. А это значит, что нам в большинстве случаев не придется, в отличие от С++, заботиться об освобождении памяти. Вышеупомянутая общеязыковая среда CLR сама вызовет сборщик мусора и очистит память.
    Стоит отметить, что .NET долгое время развивался премущественно как платформа для Windows под названием .NET Framework. В 2019 вышла последняя версия этой платформы - .NET Framework 4.8. Она больше не развивается
    С 2014 Microsoft стал развивать альтернативную платформу - .NET Core, которая уже предназначалась для разных платформ и должна была вобрать в себя все возможности устаревшего .NET Framework и добавить новую функциональность. Затем Microsoft последовательно выпустил ряд версий этой платформы: .NET Core 1, .NET Core 2, .NET Core 3, .NET 5. И текущей версией является расматриваемая в этом руководстве платформа .NET 6. Поэтому следует различать .NET Framework, который предназначен преимущественно для Windows, и кросплатформенный .NET 6. В данном руководстве речь будет идти о C# 10 в связке с .NET 6, поскольку это актуальная платформа.
    Управляемый и неуправляемый код
    Нередко приложение, созданное на C#, называют управляемым кодом (managed code). Что это значит? А это значит, что данное приложение создано на основе платформы .NET и поэтому управляется общеязыковой средой CLR, которая загружает приложение и при необходимости очищает память. Но есть также приложения, например, созданные на языке С++, которые компилируются не в общий язык CIL, как C#, VB.NET или F#, а в обычный машинный код. В этом случае .NET не управляет приложением.
    В то же время платформа .NET предоставляет возможности для взаимодействия с неуправляемым кодом..
    JIT-компиляция
    Как выше писалось, код на C# компилируется в приложения или сборки с расширениями exe или dll на языке CIL. Далее при запуске на выполнение подобного приложения происходит JIT-компиляция (Just-In-Time) в машинный код, который затем выполняется. При этом, поскольку наше приложение может быть большим и содержать кучу инструкций, в текущий момент времени будет компилироваться лишь та часть приложения, к которой непосредственно идет обращение. Если мы обратимся к другой части кода, то она будет скомпилирована из CIL в машинный код. При том уже скомпилированная часть приложения сохраняется до завершения работы программы. В итоге это повышает производительность.
    По сути это все, что вкратце надо знать о платформе .NET и языке C#. А теперь создадим первое приложение.",
                Image2 = "carbon2.png",
                Preload = "Тест на проверку знаний первой лекции",
                CorrectCount = Convert.ToInt32(item.Lecture1_test),
                VideoLink = @"https://www.youtube.com/watch?v=KyFWqbRfWIA&list=PLQOaTSbfxUtD6kMmAYc8Fooqya3pjLs1N",
                Complited = item.Lecture1_comp,
                TestNumber = "1",
                QuestionTrueFalse = {
                new QuestionTrueFalse { text = ".NET поддерживает несколько языков: наряду с C# это также VB.NET, C++, F#, а также различные диалекты других языков, привязанные к .NET, например, Delphi.NET.?", answer = "Правда", textAnswer=".NET поддерживает несколько языков. При компиляции код на любом из этих языков компилируется в сборку на общем языке CIL (Common Intermediate Language) - своего рода ассемблер платформы ." },
                new QuestionTrueFalse { text = ".NET не является переносимой платформой (с некоторыми ограничениями).?", answer = "Неправда", textAnswer="Последняя версия платформы на данный момент - .NET 6 поддерживается на большинстве современных ОС Windows, MacOS, Linux." },
                new QuestionTrueFalse { text = ".NET представляет единую для всех поддерживаемых языков библиотеку классов?", answer = "Правда", textAnswer="И какое бы приложение мы не собирались писать на C# - текстовый редактор, чат или сложный веб-сайт - так или иначе мы задействуем библиотеку классов .NET."  },
                new QuestionTrueFalse { text = ".NET 6 в ряде категорий не сильно опережает веб-приложения?", answer = "Неправда", textAnswer="Приложения на .NET 6 в принципе отличаются высокой производительностью." },
                new QuestionTrueFalse { text = "При запуске на выполнение приложения происходит JIT-компиляция (Just-In-Time) в машинный код?", answer = "Правда",  textAnswer="C# компилируется в приложения или сборки с расширениями exe или dll на языке CIL."  }
                },
            });
            Lecture.Add(new Lecture
            {
                Chapter = "Глава 2",
                Title = "Структура программы",
                Discription1 = @"   Весь код программы на языке C# помещается в файлы с расширением .cs. По умолчанию в проекте, который создается в Visual Studio (а также при использовании .NET CLI) уже есть один файл с кодом C# - файл Program.cs.
    Именно код файла Program.cs выполняется по умолчанию, если мы запустим проект на выполнение. Но при необходимости мы также можем добавлять другие файлы с кодом C#.
    Инструкции
    Базовым строительным блоком программы являются инструкции (statement). Инструкция представляет некоторое действие, например, арифметическую операцию, вызов метода, объявление переменной и присвоение ей значения. В конце каждой инструкции в C# ставится точка с запятой (;). Данный знак указывает компилятору на конец инструкции.
    Набор инструкций может объединяться в блок кода.Блок кода заключается в фигурные скобки,а инструкции помещаются между открывающей и закрывающей фигурными скобками.Например,изменим код файла Program.cs на следующий:",

                Image1 = "carbon3.png",
                Discription2 = @"   Регистрозависимость
    C# является регистрозависимым языком. Это значит, в зависимости от регистра символов какое-то определенные названия может представлять разные классы, методы, переменные и т.д. Например, для вывода на консоль используется метод WriteLine - его имя начинается именно с большой буквы: WriteLine. Если мы вместо Console.WriteLine напишем Console.writeline, то программа не скомпилируется, так как данный метод обязательно должен называться WriteLine, а не writeline или WRITELINE или как-то иначе.
    Комментарии
    Важной частью программного кода являются комментарии.Они не являются собственно частью программы,при компиляции они игнорируются.Тем не менее комментарии делают код программы более понятным,помогая понять те или иные его части.
    Eсть два типа комментариев: однострочный и многострочный.Однострочный комментарий размещается на одной строке после двойного слеша //. А многострочный комментарий заключается между символами /* текст комментария */. Он может размещаться на нескольких строках. Например:",
                Image2 ="carbon4.png",
                VideoLink = @"https://www.youtube.com/watch?v=l77oxzJUhMQ&list=PLQOaTSbfxUtD6kMmAYc8Fooqya3pjLs1N&index=2",
                Complited = item.Lecture2_comp,
                Preload = "Тест на проверку знаний второй лекции",
                CorrectCount = Convert.ToInt32(item.Lecture2_test),
                TestNumber = "2",
                QuestionTrueFalse = {
                new QuestionTrueFalse { text = "По умолчанию в проекте, который создается в Visual Studio имеется файл Program.cs?", answer = "Правда", textAnswer="По умолчанию в проекте, который создается в Visual Studio (а также при использовании .NET CLI) уже есть один файл с кодом C# - файл Program.cs." },
                new QuestionTrueFalse { text = "Program.cs по умолчанию не выполняется?", answer = "Неправда", textAnswer="Именно код файла Program.cs выполняется по умолчанию, если мы запустим проект на выполнение. Но при необходимости мы также можем добавлять другие файлы с кодом C#." },
                new QuestionTrueFalse { text = "Базовым строительным блоком программы являются инструкции (statement)?", answer = "Правда", textAnswer="Инструкция представляет некоторое действие, например, арифметическую операцию, вызов метода, объявление переменной и присвоение ей значения. В конце каждой инструкции в C# ставится точка с запятой (;)." },
                new QuestionTrueFalse { text = "Набор инструкций может объединяться в код программы?", answer = "Неправда", textAnswer="Набор инструкций может объединяться в блок кода." },
                new QuestionTrueFalse { text = "Может ли метод вывода называться WRITELINE?", answer = "Неправда", textAnswer="Если мы вместо Console.WriteLine напишем Console.writeline, то программа не скомпилируется, так как данный метод обязательно должен называться WriteLine, а не writeline или WRITELINE или как-то иначе."}
                },
            });
            Lecture.Add(new Lecture
            {
                Chapter = "Глава 2",
                Title = "Переменные и константы",
                Discription1 = @"   Для хранения данных в программе применяются переменные. Переменная представляет именнованную область памяти, в которой хранится значение определенного типа. Переменная имеет тип, имя и значение. Тип определяет, какого рода информацию может хранить переменная.
    Перед использованием любую переменную надо определить.Синтаксис определения переменной выглядит следующим образом:
    тип имя_переменной;
    Вначале идет тип переменной, потом ее имя. В качестве имени переменной может выступать любое произвольное название, которое удовлетворяет следующим требованиям:
- имя может содержать любые цифры, буквы и символ подчеркивания, при этом первый символ в имени должен быть буквой или символом подчеркивания
- в имени не должно быть знаков пунктуации и пробелов
- имя не может быть ключевым словом языка C#. Таких слов не так много, и при работе в Visual Studio среда разработки подсвечивает ключевые слова синим цветом.
    Хотя имя переменой может быть любым, но следует давать переменным описательные имена, которые будут говорить об их предназначении.
    Отличительной чертой переменных является то, что в программе можно многократно менять их значение. Например, создадим небольшую программу, в которой определим переменную, поменяем ее значение и выведем его на консоль:",
                Image1 = "carbon5.png",
                Discription2 = @"   Отличительной особенностью переменных является то, что мы можем изменить их значение в процессе работы программы. Но, кроме того, в C# есть константы. Константа должна быть обязательно инициализирована при определении, и после определения значение константы не может быть изменено
    Константы предназначены для описания таких значений, которые не должны изменяться в программе. Для определения констант используется ключевое слово const.
    Так, в данном случае определена константа NAME, которая хранит строку Tom. Нередко для название констант используется верхний регистр, но это не более чем условность.
    При использовании констант надо помнить,что объявить мы их можем только один раз и что к моменту компиляции они должны быть определены.Так,в следующем случае мы получим ошибку.",
                Image2 = "carbon6.png",
                Complited = item.Lecture3_comp,
                VideoLink = "https://www.youtube.com/watch?v=JD3Ois6i298&list=PLQOaTSbfxUtD6kMmAYc8Fooqya3pjLs1N&index=5",
                Preload = "Тест на проверку знаний третьей лекции",
                CorrectCount = Convert.ToInt32(item.Lecture3_test),
                TestNumber = "3",
                QuestionTrueFalse = {
                new QuestionTrueFalse { text = "Для хранения данных в программе применяются переменные?", answer = "Правда",  textAnswer="Для хранения данных в программе применяются переменные. Переменная представляет именнованную область памяти, в которой хранится значение определенного типа. Переменная имеет тип, имя и значение. Тип определяет, какого рода информацию может хранить переменная." },
                new QuestionTrueFalse { text = "Имя может содержать не любые цифры, буквы и символ?", answer = "Неправда", textAnswer="Имя может содержать любые цифры, буквы и символ подчеркивания, при этом первый символ в имени должен быть буквой или символом подчеркивания." },
                new QuestionTrueFalse { text = "В имени может быть знаки пунктуации и пробелы?", answer = "Неправда", textAnswer="В имени не должно быть знаков пунктуации и пробелов." },
                new QuestionTrueFalse { text = "Имя может быть ключевым словом языка C#?", answer = "Неправда",  textAnswer="Имя не может быть ключевым словом языка C#. Таких слов не так много, и при работе в Visual Studio среда разработки подсвечивает ключевые слова синим цветом." },
                new QuestionTrueFalse { text = "Константа должна быть обязательно инициализирована при определении, и после определения значение константы не может быть изменено?", answer = "Правда",  textAnswer="Отличительной особенностью переменных является то, что мы можем изменить их значение в процессе работы программы. Но, кроме того, в C# есть константы. Константа должна быть обязательно инициализирована при определении, и после определения значение константы не может быть изменено." }
                },
            });
            Lecture.Add(new Lecture
            {
                Chapter = "Глава 2",
                Title = "Литералы",
                Discription1 = @"   Логические литералы
    Есть две логических константы - true (истина) и false (ложь):
    Console.WriteLine(true);
    Console.WriteLine(false);
    Целочисленные литералы
    Целочисленные литералы представляют положительные и отрицательные целые числа, например, 1, 2, 3, 4, -7, -109. Целочисленные литералы могут быть выражены в десятичной, шестнадцатеричной и двоичной форме.
    С целыми числами в десятичной форме все должно быть понятно, так как они используются в повседневной жизни:
    Console.WriteLine(-11);
    Console.WriteLine(5);
    Console.WriteLine(505);
    Числа в двоичной форме предваряются символами 0b, после которых идет набор из нулей и единиц:
    Console.WriteLine(0b11);        // 3
    Console.WriteLine(0b1011);      // 11
    Console.WriteLine(0b100001);    // 33
    Для записи числа в шестнадцатеричной форме применяются символы 0x, после которых идет набор символов от 0 до 9 и от A до F, которые собственно представляют число:
    Console.WriteLine(0x0A);    // 10
    Console.WriteLine(0xFF);    // 255
    Console.WriteLine(0xA1);    // 161
    Вещественные литералы
    Вещественные литералы представляют дробные числа. Этот тип литералов имеет две формы. Первая форма - вещественные числа с фиксированной запятой, при которой дробную часть отделяется от целой части точкой. Например:
    3.14
    100.001
    -0.38
    Также вещественные литералы могут определяться в экспоненциальной форме MEp, где M — мантисса, E - экспонента, которая фактически означает * 10 ^  (умножить на десять в степени), а p — порядок. Например:
    Console.WriteLine(3.2e3);   // по сути равно 3.2 * 10<sup>3</sup> = 3200
    Console.WriteLine(1.2E-1);  // равно 1.2 * 10<sup>-1</sup> = 0.12
    Символьные литералы
    Символьные литералы представляют одиночные символы.Символы заключаются в одинарные кавычки.
    Символьные литералы бывают нескольких видов.Прежде всего это обычные символы:
    '2'
    'A'
    'T'
    Также мы можем передать их вывести на консоль с помощью Console.WriteLine:
    Console.WriteLine('2');
    Console.WriteLine('A');
    Console.WriteLine('T');
    Специальную группу представляют управляющие последовательности Управляющая последовательность представляет символ, перед которым ставится слеш. И данная последовательность интерпретируется определенным образом. Наиболее часто используемые последовательности:",
                Image1 = "carbon7.png",
                Discription2 = @"   И если компилятор встретит в тексте последовательность \t, то он будет воспринимать эту последовательность не как слеш и букву t, а как табуляцию - то есть длинный отступ.
    Также символы могут определяться в виде шестнадцатеричных кодов, также заключенный в одинарные кавычки.
    Еще один способ определения символов представляет использования шестнадцатеричных кодов ASCII. Для этого в одинарных кавычках указываются символы '\x', после которых идет шестнадцатеричный код символа из таблицы ASCII. Коды символов из таблицы ASCII можно посмотреть здесь.
    Например, литерал '\x78' представляет символ x:
    Console.WriteLine('\x78');    // x
    Console.WriteLine('\x5A');    // Z
    И последний способ определения символьных литералов представляет применение кодов из таблицы символов Unicode.Для этого в одинарных кавычках указываются символы '\u', после которых идет шестнадцатеричный код Unicode. Например, код '\u0411' представляет кириллический символ 'Б':
    Console.WriteLine('\u0420');    // Р
    Console.WriteLine('\u0421');    // С
    Строковые литералы
    Строковые литералы представляют строки. Строки заключаются в двойные кавычки:",
                Image2 = "carbon8.png",
                Complited = item.Lecture4_comp,
                TestNumber = "4",
                VideoLink = "https://www.youtube.com/watch?v=JTn3m-8eMx4&list=PLQOaTSbfxUtD6kMmAYc8Fooqya3pjLs1N&index=3",
                Preload = "Тест на проверку знаний четвертой лекции",
                CorrectCount = Convert.ToInt32(item.Lecture4_test),
                QuestionTrueFalse = {
                new QuestionTrueFalse { text = "Литералы представляют неизменяемые значения?", answer = "Правда",  textAnswer="Литералы представляют неизменяемые значения (иногда их еще называют константами)." },
                new QuestionTrueFalse { text = "Вещественные литералы не представляют дробные числа?", answer = "Неправда", textAnswer="Вещественные литералы представляют дробные числа. Этот тип литералов имеет две формы. Первая форма - вещественные числа с фиксированной запятой, при которой дробную часть отделяется от целой части точкой." },
                new QuestionTrueFalse { text = "Символьные литералы не представляют одиночные символы?", answer = "Неправда", textAnswer="Символьные литералы представляют одиночные символы. Символы заключаются в одинарные кавычки." },
                new QuestionTrueFalse { text = "Управляющая последовательность представляет символ, перед которым ставится слеш?", answer = "Правда",  textAnswer="Специальную группу представляют управляющие последовательности Управляющая последовательность представляет символ, перед которым ставится слеш. И данная последовательность интерпретируется определенным образом." },
                new QuestionTrueFalse { text = "Строки заключаются в двойные кавычки?", answer = "Правда",  textAnswer="Строковые литералы представляют строки." }
                },
            });
            Lecture.Add(new Lecture
            {
                Chapter = "Глава 2",
                Title = "Типы данных",
                Discription1 = @"   Как и во многих языках программирования, в C# есть своя система типов данных, которая используется для создания переменных. Тип данных определяет внутреннее представление данных, множество значений, которые может принимать объект, а также допустимые действия, которые можно применять над объектом.
    В языке C# есть следующие базовые типы данных:
- bool: хранит значение true или false (логические литералы). Представлен системным типом System.Boolean
- byte: хранит целое число от 0 до 255 и занимает 1 байт. Представлен системным типом System.Byte
- sbyte: хранит целое число от -128 до 127 и занимает 1 байт. Представлен системным типом System.SByte
- short: хранит целое число от -32768 до 32767 и занимает 2 байта. Представлен системным типом System.Int16
- ushort: хранит целое число от 0 до 65535 и занимает 2 байта. Представлен системным типом System.UInt16
- int: хранит целое число от -2147483648 до 2147483647 и занимает 4 байта. Представлен системным типом System.Int32. 
- uint: хранит целое число от 0 до 4294967295 и занимает 4 байта. Представлен системным типом System.UInt32
- long: хранит целое число от –9 223 372 036 854 775 808 до 9 223 372 036 854 775 807 и занимает 8 байт. Представлен системным типом System.Int64
- ulong: хранит целое число от 0 до 18 446 744 073 709 551 615 и занимает 8 байт. Представлен системным типом System.UInt64
- float: хранит число с плавающей точкой от -3.4*1038 до 3.4*1038 и занимает 4 байта. Представлен системным типом System.Single
- double: хранит число с плавающей точкой от ±5.0*10-324 до ±1.7*10308 и занимает 8 байта. Представлен системным типом System.Double
- decimal: хранит десятичное дробное число. Если употребляется без десятичной запятой, имеет значение от ±1.0*10-28 до ±7.9228*1028, может хранить 28 знаков после запятой и занимает 16 байт. Представлен системным типом System.Decimal
- char: хранит одиночный символ в кодировке Unicode и занимает 2 байта. Представлен системным типом System.Char. Этому типу соответствуют символьные литералы
- string: хранит набор символов Unicode. Представлен системным типом System.String. Этому типу соответствуют строковые литералы.
- object: может хранить значение любого типа данных и занимает 4 байта на 32-разрядной платформе и 8 байт на 64-разрядной платформе. Представлен системным типом System.Object, который является базовым для всех других типов и классов .NET.
",
                Image1 = "carbon9.png",
                Discription2 = @"   Использование суффиксов
    При присвоении значений надо иметь в виду следующую тонкость: все вещественные литералы (дробные числа) рассматриваются как значения типа double. И чтобы указать, что дробное число представляет тип float или тип decimal, необходимо к литералу добавлять суффикс: F/f - для float и M/m - для decimal.
    Подобным образом все целочисленные литералы рассматриваются как значения типа int. Чтобы явным образом указать, что целочисленный литерал представляет значение типа uint, надо использовать суффикс U/u, для типа long - суффикс L/l, а для типа ulong - суффикс UL/ul:
",
                Image2 = "carbon10.png",
                Complited = item.Lecture5_comp,
                CorrectCount = Convert.ToInt32(item.Lecture5_test),
                TestNumber = "5",
                VideoLink = "https://www.youtube.com/watch?v=fNjVCSEXpDM&list=PLQOaTSbfxUtD6kMmAYc8Fooqya3pjLs1N&index=4",
                Preload = "Тест на проверку знаний пятой лекции",
                QuestionTrueFalse = {
                new QuestionTrueFalse { text = "Bool: хранит значение true или false (логические литералы)?", answer = "Правда",  textAnswer="Хранит значение true или false (логические литералы). Представлен системным типом System.Boolean." },
                new QuestionTrueFalse { text = "Short: хранит целое число от -32768 до 32767 и занимает 4 байта?", answer = "Неправда", textAnswer="Xранит целое число от -32768 до 32767 и занимает 2 байта." },
                new QuestionTrueFalse { text = "Char: хранит одиночный символ в кодировке Unicode и занимает 2 байта?", answer = "Правда", textAnswer="Xранит одиночный символ в кодировке Unicode и занимает 2 байта. Представлен системным типом System.Char. Этому типу соответствуют символьные литералы." },
                new QuestionTrueFalse { text = "String: хранит набор символов Xida. Представлен системным типом System.String?", answer = "Неправда",  textAnswer="Хранит набор символов Unicode. Представлен системным типом System.String." },
                new QuestionTrueFalse { text = "Object: может хранить значение любого типа данных и занимает 4 байта на 32-разрядной платформе и 8 байт на 64-разрядной платформе?", answer = "Правда",  textAnswer="Может хранить значение любого типа данных и занимает 4 байта на 32-разрядной платформе и 8 байт на 64-разрядной платформе. Представлен системным типом System.Object, который является базовым для всех других типов и классов .NET." }
                },
            });
            Lecture.Add(new Lecture
            {
                Chapter = "Глава 2",
                Title = "Операции присваивания",
                Discription1 = @"   Операции присвоения устанавливают значение. В операциях присвоения участвуют два операнда, причем левый операнд может представлять только модифицируемое именованное выражение, например, переменную
    Как и во многих других языках программирования, в C# имеется базовая операция присваивания =, которая присвоивает значение правого операнда левому операнду:
    int number = 23;
    Здесь переменной number присваивается число 23. Переменная number представляет левый операнд, которому присваивается значение правого операнда, то есть числа 23.
    Также можно выполнять множественно присвоение сразу нескольких переменным одновременно:
    int a, b, c;
    a = b = c = 34;
    Стоит отметить, что операции присвоения имеют низкий приоритет. И вначале будет вычисляться значение правого операнда и только потом будет идти присвоение этого значения левому операнду. Например:",
                Image1 = "carbon11.png",
                Discription2 = @"   Сначала будет вычисляться выражение 34 * 2 / 4, затем полученное значение будет присвоено переменным.
    Кроме базовой операции присвоения в C# есть еще ряд операций:
    +=: присваивание после сложения. Присваивает левому операнду сумму левого и правого операндов: выражение A += B равнозначно выражению A = A + B
    -=: присваивание после вычитания. Присваивает левому операнду разность левого и правого операндов: A -= B эквивалентно A = A - B
    *=: присваивание после умножения. Присваивает левому операнду произведение левого и правого операндов: A *= B эквивалентно A = A * B
    /=: присваивание после деления. Присваивает левому операнду частное левого и правого операндов: A /= B эквивалентно A = A / B
    %=: присваивание после деления по модулю. Присваивает левому операнду остаток от целочисленного деления левого операнда на правый: A %= B эквивалентно A = A % B
    &=: присваивание после поразрядной конъюнкции. Присваивает левому операнду результат поразрядной конъюнкции его битового представления с битовым представлением правого операнда: A &= B эквивалентно A = A & B
    |=: присваивание после поразрядной дизъюнкции. Присваивает левому операнду результат поразрядной дизъюнкции его битового представления с битовым представлением правого операнда: A |= B эквивалентно A = A | B
    ^=: присваивание после операции исключающего ИЛИ. Присваивает левому операнду результат операции исключающего ИЛИ его битового представления с битовым представлением правого операнда: A ^= B эквивалентно A = A ^ B
    <<=: присваивание после сдвига разрядов влево. Присваивает левому операнду результат сдвига его битового представления влево на определенное количество разрядов, равное значению правого операнда: A <<= B эквивалентно A = A << B
    >>=: присваивание после сдвига разрядов вправо. Присваивает левому операнду результат сдвига его битового представления вправо на определенное количество разрядов, равное значению правого операнда: A >>= B эквивалентно A = A >> B
    Применение операций присвоения:",
                Image2 = "carbon12.png",
                Complited = item.Lecture6_comp,
                CorrectCount = Convert.ToInt32(item.Lecture6_test),
                TestNumber = "6",
                VideoLink = "https://www.youtube.com/watch?v=CyMOlixfPMA&list=PLQOaTSbfxUtD6kMmAYc8Fooqya3pjLs1N&index=10",
                Preload = "Тест на проверку знаний шестой лекции",
                QuestionTrueFalse = {
                new QuestionTrueFalse { text = "В операциях присвоения участвуют три операнда?", answer = "Неправда",  textAnswer="В операциях присвоения участвуют два операнда, причем левый операнд может представлять только модифицируемое именованное выражение, например, переменную." },
                new QuestionTrueFalse { text = "A *= B эквивалентно A = A * B?", answer = "Правда", textAnswer="*=: присваивание после умножения." },
                new QuestionTrueFalse { text = "A || B эквивалентно A = A | B?", answer = "Неправда", textAnswer="|=: присваивание после поразрядной дизъюнкции." },
                new QuestionTrueFalse { text = "Базовая операция присваивания в C# это: := ?", answer = "Неправда",  textAnswer="Как и во многих других языках программирования, в C# имеется базовая операция присваивания =." },
                new QuestionTrueFalse { text = "A <<= B эквивалентно A = A >> B?", answer = "Неправда",  textAnswer="<<=: присваивание после сдвига разрядов влево. Присваивает левому операнду результат сдвига его битового представления влево на определенное количество разрядов, равное значению правого операнда: A <<= B эквивалентно A = A << B." }
                },
            });
            Lecture.Add(new Lecture
            {
                Chapter = "Глава 2",
                Title = "Конструкция if..else и тернарная операция",
                Discription1 = @"   Условные конструкции - один из базовых компонентов многих языков программирования, которые направляют работу программы по одному из путей в зависимости от определенных условий. Одной из таких конструкций в языке программирования C# является конструкция if..else
    Конструкция if/else проверяет истинность некоторого условия и в зависимости от результатов проверки выполняет определенный код.
    Ее простейшая форма состоит из блока if:
    if(условие)
    {
        выполняемые инструкции
    }
    После ключевого слова if ставится условие. Условие должно представлять значение типа bool. Это может быть непосредственно значение типа bool или результат условного выражения или другого выражения, которое возвращает значение тиа bool. И если это условие истинно (равно true), то срабатывает код, который помещен далее после условия внутри фигурных скобок.",
                Image1 = "carbon13.png",
                Discription2 = @"   Выражение else
    Но что, если мы захотим, чтобы при несоблюдении условия также выполнялись какие-либо действия? В этом случае мы можем добавить блок else.
    else if
    Но в примере выше при сравнении чисел мы можем насчитать три состояния: первое число больше второго, первое число меньше второго и числа равны. Используя конструкцию else if, мы можем обрабатывать дополнительные условия.
    Тернарную операция также позволяет проверить некоторое условие и в зависимости от его истинности выполнить некоторые действия. Она имеет следующий синтаксис:
    [первый операнд - условие] ? [второй операнд] : [третий операнд]
",
                Image2 = "carbon14.png",
                Complited = item.Lecture7_comp,
                CorrectCount = Convert.ToInt32(item.Lecture7_test),
                TestNumber = "7",
                VideoLink = "https://www.youtube.com/watch?v=qrPuaaVGEp4&list=PLQOaTSbfxUtD6kMmAYc8Fooqya3pjLs1N&index=16",
                Preload = "Тест на проверку знаний седьмой лекции",
                QuestionTrueFalse = {
                new QuestionTrueFalse { text = "Условные конструкции - один из базовых компонентов многих языков программирования, которые направляют работу программы по одному из путей в зависимости от определенных условий?", answer = "Правда",  textAnswer="Условные конструкции - один из базовых компонентов многих языков программирования, которые направляют работу программы по одному из путей в зависимости от определенных условий." },
                new QuestionTrueFalse { text = "Ее простейшая форма состоит из блока if else?", answer = "Неправда", textAnswer="Ее простейшая форма состоит из блока if." },
                new QuestionTrueFalse { text = "При несоблюдении условия чтобы также выполнялись какие-либо действия нужно использовать else?", answer = "Правда", textAnswer="Но что, если мы захотим, чтобы при несоблюдении условия также выполнялись какие-либо действия? В этом случае мы можем добавить блок else." },
                new QuestionTrueFalse { text = "Блок else выполняется, если условие после if ложно, то есть равно false?", answer = "Правда",  textAnswer="Блок else не выполняется, если условие после if правда, то есть равно true." },
                new QuestionTrueFalse { text = "[первый операнд - условие] ? [второй операнд] : [третий операнд], правильно ли записан тернарный оператор?", answer = "Правда",  textAnswer="Здесь сразу три операнда. В зависимости от условия тернарная операция возвращает второй или третий операнд: если условие равно true, то возвращается второй операнд; если условие равно false, то третий." }
                },
            });
            Lecture.Add(new Lecture
            {
                Chapter = "Глава 2",
                Title = "Циклы",
                Discription1 = @"   Цикл for
    Цикл for имеет следующее формальное определение:
    for ([действия_до_выполнения_цикла]; [условие]; [действия_после_выполнения])
    {
        // действия
    }
    Объявление цикла for состоит из трех частей. Первая часть объявления цикла - некоторые действия, которые выполняются один раз до выполнения цикла. Обычно здесь определяются переменные, которые будут использоваться в цикле.
    Вторая часть - условие, при котором будет выполняться цикл. Пока условие равно true, будет выполняться цикл.
    И третья часть - некоторые действия, которые выполняются после завершения блока цикла. Эти действия выполняются каждый раз при завершении блока цикла.
    После объявления цикла в фигурных скобках помещаются сами действия цикла.
    Рассмотрим стандартный цикл for:
    for (int i = 1; i < 4; i++)
    {
        Console.WriteLine(i);
    }
    Здесь первая часть объявления цикла - int i = 1 - создает и инициализирует переменную i.
    Вторая часть - условие i < 4. То есть пока переменная i меньше 4, будет выполняться цикл.
    И третья часть - действия, выполняемые после завершения действий из блока цикла - увеличение переменной i на единицу.
    Весь процесс цикла можно представить следующим образом:
- Определяется переменная int i = 1
- Проверяется условие i < 4. Оно истинно (так как 1 меньше 4), поэтому выполняется блок цикла, а именно инструкция Console.WriteLine(i), которая выводит на консоль значение переменной i
- Блок цикла закончил выполнение, поэтому выполняется треться часть объявления цикла - i++. После этого переменная i будет равна 2.
- Снова проверяется условие i < 4. Оно истинно (так как 2 меньше 4), поэтому опять выполняется блок цикла - Console.WriteLine(i)
- Блок цикла закончил выполнение, поэтому снова выполняется выражение i++. После этого переменная i будет равна 3.
- Снова проверяется условие i < 4. Оно истинно (так как 3 меньше 4), поэтому опять выполняется блок цикла - Console.WriteLine(i)
- Блок цикла закончил выполнение, поэтому снова выполняется выражение i++. После этого переменная i будет равна 4.
- Снова проверяется условие i < 4. Теперь оно возвражает false, так как значение переменной i НЕ меньше 4, поэтому цикл завершает выполнение. Далее уже выполняется остальная часть программы, которая идет после цикла",
                Image1 = "carbon15.png",
                Discription2 = @"   Цикл do..while
    В цикле do сначала выполняется код цикла, а потом происходит проверка условия в инструкции while. И пока это условие истинно, цикл повторяется.
    do
    {
        действия цикла
    }
    while (условие)
    Например:
    int i = 6;
    do
    {
        Console.WriteLine(i);
        i--;
    }
    while (i > 0);
    Здесь код цикла сработает 6 раз, пока i не станет равным нулю. Но важно отметить, что цикл do гарантирует хотя бы единократное выполнение действий, даже если условие в инструкции while не будет истинно. То есть мы можем написать:
    int i = -1;
    do
    {
        Console.WriteLine(i);
        i--;
    }
    while (i > 0);
    Хотя у нас переменная i меньше 0, цикл все равно один раз выполнится.
    Цикл while
    В отличие от цикла do цикл while сразу проверяет истинность некоторого условия, и если условие истинно, то код цикла выполняется:
    while (условие)
    {
        действия цикла
    }
    Например:
    int i = 6;
    while (i > 0)
    {
        Console.WriteLine(i);
        i--;
    }
    Цикл foreach
    Цикл foreach предназначен для перебора набора или коллекции элементов. Его общее определение:
    foreach(тип_данных переменная in коллекция)
    {
        // действия цикла
    }
    После оператора foreach в скобках сначала идет определение переменной. Затем ключевое слово in и далее коллекция, элементы которой надо перебрать.
    При выполнении цикл последовательно перебирает элементы коллекции и помещает их в переменную, и таким образом в блоке цикла мы можем выполнить с ними некоторые действия.
    Например, возьмем строку. Строка по сути - это коллекция символов. И .NET позволяет перебрать все элементы строки - ее символы с помощью цикла foreach.",
                Image2 = "carbon16.png",
                Complited = item.Lecture8_comp,
                CorrectCount = Convert.ToInt32(item.Lecture8_test),
                TestNumber = "8",
                VideoLink = "https://www.youtube.com/watch?v=MFSx0tbcRqc&list=PLQOaTSbfxUtD6kMmAYc8Fooqya3pjLs1N&index=21",
                Preload = "Тест на проверку знаний восьмой лекции",
                QuestionTrueFalse = {
                new QuestionTrueFalse { text = "Объявление цикла for состоит из четырёх частей?", answer = "Неправда",  textAnswer="Объявление цикла for состоит из трех частей." },
                new QuestionTrueFalse { text = "В цикле do сначала выполняется код цикла, а потом происходит проверка условия в инструкции while?", answer = "Правда", textAnswer="В цикле do сначала выполняется код цикла, а потом происходит проверка условия в инструкции while." },
                new QuestionTrueFalse { text = "Цикл while сразу не проверяет истинность некоторого условия, и если условие не истинно, то код цикла выполняется?", answer = "Неправда", textAnswer="Цикл while сразу проверяет истинность некоторого условия, и если условие истинно, то код цикла выполняется." },
                new QuestionTrueFalse { text = "Цикл foreach предназначен для перебора набора или коллекции индексов?", answer = "Неправда",  textAnswer="Цикл foreach предназначен для перебора набора или коллекции элементов." },
                new QuestionTrueFalse { text = "В С# есть оператор break?", answer = "Правда",  textAnswer="Иногда возникает ситуация, когда требуется выйти из цикла, не дожидаясь его завершения. В этом случае мы можем воспользоваться оператором break." }
                },
            });
            Lecture.Add(new Lecture
            {
                Chapter = "Глава 2",
                Title = "Массивы",
                Discription1 = @"   Массив представляет набор однотипных данных. Объявление массива похоже на объявление переменной за тем исключением, что после указания типа ставятся квадратные скобки:
    тип_переменной[] название_массива;
    Например, определим массив целых чисел:
    int[] numbers;
    После определения переменной массива мы можем присвоить ей определенное значение
    int[] nums = new int[4];
    Здесь вначале мы объявили массив nums, который будет хранить данные типа int. Далее используя операцию new, мы выделили память для 4 элементов массива: new int[4]. Число 4 еще называется длиной массива. При таком определении все элементы получают значение по умолчанию, которое предусмотренно для их типа. Для типа int значение по умолчанию - 0.   
    Также мы сразу можем указать значения для этих элементов:
    int[] nums2 = new int[4] { 1, 2, 3, 5 }; 
    int[] nums3 = new int[] { 1, 2, 3, 5 };
    int[] nums4 = new[] { 1, 2, 3, 5 }; 
    int[] nums5 = { 1, 2, 3, 5 };
    Все перечисленные выше способы будут равноценны.
    Индексы и получение элементов массива
    Для обращения к элементам массива используются индексы.Индекс представляет номер элемента в массиве,
                при этом нумерация начинается с нуля,
                поэтому индекс первого элемента будет равен 0,
                индекс четвертого элемента - 3.
    Используя индексы,мы можем получить элементы массива:
    int[] numbers = { 1, 2, 3, 5 };
    // получение элемента массива
    Console.WriteLine(numbers[3]);  // 5

    // получение элемента массива в переменную
    var n = numbers[1];     // 2
    Console.WriteLine(n);  // 2
    Также мы можем изменить элемент массива по индексу:
    int[] numbers = { 1, 2, 3, 5 };
    // изменим второй элемент массива
    numbers[1] = 505;

    Console.WriteLine(numbers[1]);  // 505
    И так как у нас массив определен только для 4 элементов, то мы не можем обратиться, например, к шестому элементу.Если мы так попытаемся сделать, то мы получим ошибку во время выполнения:
    int[] numbers = { 1, 2, 3, 5 };
    Console.WriteLine(numbers[6]);  // ! Ошибка - в массиве только 4 элемента
    Свойство Length и длина массива
    каждый массив имеет свойство Length, которое хранит длину массива.Например, получим длину выше созданного массива numbers:
    int[] numbers = { 1, 2, 3, 5 };
    Console.WriteLine(numbers.Length);  // 4
    Для получения длины массива после названия массива через точку указывается свойство Length: numbers.Length.
    Получение элементов с конца массива
    Благодаря наличию свойства Length, мы можем вычислить индекс последнего элемента массива - это длина массива -1.Например, если длина массива - 4(то есть массив имеет 4 элемента), то индекс последнего элемента будет равен 3.И, используя свойство Length, мы можем легко получить элементы с конца массива:
    int[] numbers = { 1, 2, 3, 5 };
    Console.WriteLine(numbers[numbers.Length - 1]);  // 5 - первый с конца или последний элемент
    Console.WriteLine(numbers[numbers.Length - 2]);  // 3 - второй с конца или предпоследний элемент
    Console.WriteLine(numbers[numbers.Length - 3]);  // 2 - третий элемент с конца",
            Image1 = "carbon17.png",
                Discription2 = @"   Многомерные массивы
    Массивы характеризуются таким понятием как ранг или количество измерений. Выше мы рассматривали массивы, которые имеют одно измерение (то есть их ранг равен 1) - такие массивы можно представлять в виде ряда (строки или столбца) элемента. Но массивы также бывают многомерными. У таких массивов количество измерений (то есть ранг) больше 1.
    Массивы которые имеют два измерения (ранг равен 2) называют двухмерными. Например, создадим одномерный и двухмерный массивы, которые имеют одинаковые элементы:
    int[] nums1 = new int[] { 0, 1, 2, 3, 4, 5 };
    int[,] nums2 = { { 0, 1, 2 }, { 3, 4, 5 } };
    Визуально оба массива можно представить следующим образом:
    Одномерный массив nums1
    Двухмерный массив nums2
    Поскольку массив nums2 двухмерный, он представляет собой простую таблицу. Все возможные способы определения двухмерных массивов:
    int[,] nums1;
    int[,] nums2 = new int[2, 3];
    int[,] nums3 = new int[2, 3] { { 0, 1, 2 }, { 3, 4, 5 } };
    int[,] nums4 = new int[,] { { 0, 1, 2 }, { 3, 4, 5 } };
    int[,] nums5 = new [,]{ { 0, 1, 2 }, { 3, 4, 5 } };
    int[,] nums6 = { { 0, 1, 2 }, { 3, 4, 5 } };
    Массивы могут иметь и большее количество измерений. Объявление трехмерного массива могло бы выглядеть так:
    int[,,] nums3 = new int[2, 3, 4];
    Массив массивов
    От многомерных массивов надо отличать массив массивов или так называемый <зубчатый массив>:
    int[][] nums = new int[3][];
    nums[0] = new int[2] { 1, 2 };          // выделяем память для первого подмассива
    nums[1] = new int[3] { 1, 2, 3 };       // выделяем память для второго подмассива
    nums[2] = new int[5] { 1, 2, 3, 4, 5 }; // выделяем память для третьего подмассива
    Здесь две группы квадратных скобок указывают, что это массив массивов, то есть такой массив, который в свою очередь содержит в себе другие массивы. Причем длина массива указывается только в первых квадратных скобках, все последующие квадратные скобки должны быть пусты: new int[3][].В данном случае у нас массив nums содержит три массива.Причем размерность каждого из этих массивов может не совпадать.
    Альтернативное определение массива массивов:
    int[][] numbers = {
        new int[] { 1, 2 },
        new int[] { 1, 2, 3 },
        new int[] { 1, 2, 3, 4, 5 }
    }; ",
                Image2 = "carbon18.png",
                Complited = item.Lecture9_comp,
                CorrectCount = Convert.ToInt32(item.Lecture9_test),
                TestNumber = "9",
                VideoLink = "https://www.youtube.com/watch?v=O6tWN5iPU08&list=PLQOaTSbfxUtD6kMmAYc8Fooqya3pjLs1N&index=31",
                Preload = "Тест на проверку знаний девятой лекции",
                QuestionTrueFalse = {
                new QuestionTrueFalse { text = "Массив представляет набор однотипных данных?", answer = "Правда",  textAnswer="Массив представляет набор однотипных данных." },
                new QuestionTrueFalse { text = "Для обращения к элементам массива используются методы доступа?", answer = "Неправда", textAnswer="Для обращения к элементам массива используются индексы." },
                new QuestionTrueFalse { text = "При длине массива 4 индес последнего элемента равен 4?", answer = "Неправда", textAnswer="Благодаря наличию свойства Length, мы можем вычислить индекс последнего элемента массива - это длина массива - 1. Например, если длина массива - 4 (то есть массив имеет 4 элемента), то индекс последнего элемента будет равен 3." },
                new QuestionTrueFalse { text = "Массивы которые имеют два измерения (ранг равен 2) называют двухмерными?", answer = "Правда",  textAnswer="Массивы характеризуются таким понятием как ранг или количество измерений. Выше мы рассматривали массивы, которые имеют одно измерение (то есть их ранг равен 1) - такие массивы можно представлять в виде ряда (строки или столбца) элемента. Но массивы также бывают многомерными. У таких массивов количество измерений (то есть ранг) больше 1." },
                new QuestionTrueFalse { text = "Массив массивов, то есть такой массив, который в свою очередь содержит в себе другие массивы?", answer = "Правда",  textAnswer="Здесь две группы квадратных скобок указывают, что это массив массивов, то есть такой массив, который в свою очередь содержит в себе другие массивы. Причем длина массива указывается только в первых квадратных скобках, все последующие квадратные скобки должны быть пусты: new int[3][]. В данном случае у нас массив nums содержит три массива. Причем размерность каждого из этих массивов может не совпадать." }
                },
            });
            Lecture.Add(new Lecture
            {
                Chapter = "Глава 2",
                Title = "Методы",
                Discription1 = @"   Определение метода
    Определим один метод:
    void SayHello()
    {
        Console.WriteLine();
    }
    Здесь определен метод SayHello, который выводит некоторое сообшение.К названиям методов предъявляются в принципе те же требования, что и к названиям переменных.Однако, как правило, названия методов начинаются с большой буквы.
    Перед названием метода идет возвращаемый тип данных.Здесь это тип void, который указыает, что фактически ничего не возвращает, он просто производит некоторые действия.
    После названия метода в скобках идет перечисление параметров.Но в данном случае скобки пустые, что означает, что метод не принимает никаких параметров.
    После списка параметров в круглых скобках идет блок кода, который представляет набор выполняемых методом инструкций.В данном случае блок метода SayHello содержит только одну инструкцию, которая выводит строку на консоль:
    Console.WriteLine();
    Но если мы запустим данный проект, то мы не увидим никакой строки, которую должен выводить метод SayHello.Потому что после определения метод еще надо вызвать, чтобы он выполнил свою работу.
    Вызов методов
    Чтобы использовать метод SayHello, нам надо его вызвать.Для вызова метода указывается его имя, после которого в скобках идут значения для его параметров(если метод принимает параметры).
    название_метода(значения_для_параметров_метода);
    Например, вызов метода SayHello будет выглядеть следующим образом:
    SayHello();
    Поскольку метод не принимает никаких параметров, то после названия метода идут пустые скобки.
    Объединим определение и вызов метода:",
                Image1 = "carbon19.png",
                Discription2 = @"   Сокращенная запись методов
    Если метод в качестве тела определяет только одну инструкцию, то мы можем сократить определение метода. Например, допустим у нас есть метод:",
                Image2 = "carbon20.png",
                Complited = item.Lecture10_comp,
                CorrectCount = Convert.ToInt32(item.Lecture10_test),
                TestNumber = "10",
                VideoLink = "https://www.youtube.com/watch?v=Xk8vRnm6xtc&list=PLQOaTSbfxUtD6kMmAYc8Fooqya3pjLs1N&index=46",
                Preload = "Тест на проверку знаний десятой лекции",
                QuestionTrueFalse = {
                new QuestionTrueFalse { text = "Тип void указыает, что метод фактически ничего не возвращает?", answer = "Правда",  textAnswer="Перед названием метода идет возвращаемый тип данных. Здесь это тип void, который указыает, что фактически ничего не возвращает, он просто производит некоторые действия." },
                new QuestionTrueFalse { text = "Метод - это именованный блок кода, который выполняет некоторые действия?", answer = "Правда", textAnswer="Если переменные хранят некоторые значения, то методы содержат собой набор инструкций, которые выполняют определенные действия. По сути метод - это именованный блок кода, который выполняет некоторые действия." },
                new QuestionTrueFalse { text = "Для вызова метода указывается имя метода?", answer = "Правда", textAnswer="Для вызова метода указывается его имя, после которого в скобках идут значения для его параметров (если метод принимает параметры)." },
                new QuestionTrueFalse { text = "Если метод в качестве тела определяет только одну инструкцию, то мы не можем сократить определение метода?", answer = "Неправда",  textAnswer="Если метод в качестве тела определяет только одну инструкцию, то мы можем сократить определение метода." },
                new QuestionTrueFalse { text = "При сокращенном методе ставиться =>>?", answer = "Неправда",  textAnswer="После списка параметров ставится оператор =>, после которого идет выполняемая инструкция." }
                },
            });
            return Lecture;
        }
    }
}
